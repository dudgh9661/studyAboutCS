# Operating System

<h2>Process vs Thread</h2>

> 피자에 비유해보자!
>> 피자 레시피 <-> 프로그램 ( 코드로 이루어진 파일 )
>> 
>> 피자 레시피로 만든 피자 <-> 프로세스 ( 프로그램이 실행된 상태 )

---

### _Program이 Process가 되기 위해선, '메모리'에 올라가야하고 'PCB'가 만들어진다!_ ###

#### Process 메모리 구조

- ***Code*** : 실행 명령을 포함하는 코드들
- ***Data*** : Static 변수 혹은 Global 변수
- ***Heap*** : 동적 메모리 영역
- ***Stack*** : 지역변수, 매개변수, 반환 값등 일시적인 데이터

#### PCB 메모리 구조

- ***Pointer*** : Process의 준비상태, 대기상태의 큐를 구현하기 위한 구역
- ***Process State*** : 현재 Process 상태를 저장
- ***PID*** : Process의 고유 번호
- ***Program Count*** :: 다음 명령어를 가리킨다

---

**CPU는 1개의 Process만 수행할 수 있다.** 
> 즉, 유튜브로 노래를 듣다가 인텔리제이로 코딩을 하려고 하면 노래가 꺼진다. 
> 
> 다수의 Process를 동시에 실행하기 위해, 여러개의 프로세스를 시분할로 즉, 짧은 시간 텀으로 프로세스를 CPU에 전환하며 적재해서 실행한다. 사용자 입장에서 봤을 때, 이것이 동시에 실행되는 것처럼 느낀다.

#### Process A, B 실행 흐름 ####

1. A가 CPU에 적재된다.
2. B는 준비상태가 된다.
3. B를 실행하기 위해선, A가 준비상태로 내려간 후 B가 CPU에 적재된다.
4. 다시 A가 실행되기 위해선, B가 준비상태로 내려가고 A가 CPU에 적재된다.

이 과정을 ***Context Switching*** 이라고 한다.

 - _이 복잡한 과정을 해결하기 위해 등장한 것, 경량화된 프로세스인 ***Thread***_
  > 이 Thread가 경량화된 Process인 이유는,
  > > Code, Data, Heap 메모리 영역을 서로 공유하기 때문이다.
  > > 
  > > 즉, 각 Thread는 Stack 영역만 따로 가지고 있다. 자원을 공유하기 때문에 'Context Switching'이 일어날 때, 캐식 적중률이 올라간다. 
  > > 
  > > 쉽게 말해, 모조리 다 빼고 다시 넣을 필요가 없다는 것!!

#### 예시

회의실을 사용할 때, 모니터, 스피커, 리모컨을 사용한다. 다음 예약 팀이 들어올 때, 이전 프로세스 실행의 경우는 어차피 사용할 모니터, 스피커, 리모컨을 모조리 챙겨서 나간 경우이다. 다음 팀은 그것을 다시 다 챙겨서 들어와야지만 사용할 수 있다.

**그러나, Thread의 Context Switching은 공용으로 사용하는 자원은 그대로 두고 개인 노트북만 가져와서 연결하는 경우이다.**

---

### 멀티 Process vs 멀티 Thread ###
- 처리 방식의 일종이다. 즉 **1개**의 어플리케이션에 대한 처리 방식이라고 생각하자!

#### 예시

A 애플리케이션이 여러개의 일을 처리한다고 가정하자. 여러 사용자가 로그인을 요청하는 상황을 가정하자.

하나의 Process는 매번 하나의 로그인만 처리가 가능하다.
> 때문에 부모 Process를 fork() 하여 여러 자식 Process를 만들어 일을 처리한다.
> > 이 때, 자식 Process는 부모 Process와 별개의 메모리 영역을 확보한다.

반면, Thread는 1개의 Process 내에서 구분이 지어진 **실행단위**이다.
> 인텔리제이를 사용하면서 코드 수정과 동시에, 테스트코드도 돌리는 것과 같이 한 앱에서 작업의 단위가 나누어지는 경우가 있다. 
> > 이 때, 각각의 Thread가 그 작업들을 담당한다.

----

***Process***는 독립적인 메모리를 가지기 때문에 **IPC**를 통해서 통신한다. 
> 예를 들어, 같은 작업을 2명이 2개의 회의실에서 진행하다가 논의할 일이 생기면 밖으로 나와서 이야기하고 다시 들어가는 상황
> > 더 많은 메모리를 차지하고, Context Switching 비용도 비싸다.
> > 
> > 하지만 독립적인 메모리를 갖기 때문에 동기화 작업을 신경쓰지 않아도 된다.

***Thread***는 자원을 공유하기 때문에 **동기화 작업을 따로 처리해줘야한다.**
> 2명이 1개의 회의실에서 같이 일을 처리하기 때문에 논의할 일이 생기면 바로 이야기할 수 있다. (IPC가 필요하지 않음)
> > 공유된 자원으로 메모리로 인해 메모리를 효율적으로 사용할 수 있고 통신 비용, Context Switching 비용도 절감된다.

#### 그렇다면 멀티 스레드가 훨씬 좋은데 왜 멀티 프로세스를 쓸까?

- **IE**는 탭 화면을 **멀티 스레드**를 사용한다. 때문에 1개의 탭에 문제가 생기면, IE 자체가 다운된다.
 > 자원을 공유하기 때문에!

- 반면, **구글 크롬**은 **멀티 프로세스**를 사용하기 때문에 1개의 탭이 다운되더라도 크롬 자체가 다운되지 않는다.

---

###  멀티 코어
 > **하드웨어 측면으로 바라보자**
 
 > **관련 키워드는 '동시성'과 '병렬 처리'**
 
 - **싱글 코어** : 시분할로 CPU가 프로세스를 점유 ( 동시성 )
 - **멀티 코어** : 2개의 코어에서 실행 단위가 각각 진행 ( 병렬 처리 )



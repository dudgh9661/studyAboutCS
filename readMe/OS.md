# Operating System

<h2>Process vs Thread</h2>

> 피자에 비유해보자!
>> 피자 레시피 <-> 프로그램 ( 코드로 이루어진 파일 )
>> 
>> 피자 레시피로 만든 피자 <-> 프로세스 ( 프로그램이 실행된 상태 )

---

### _Program이 Process가 되기 위해선, '메모리'에 올라가야하고 'PCB'가 만들어진다!_ ###

#### Process 메모리 구조

- ***Code*** : 실행 명령을 포함하는 코드들
- ***Data*** : Static 변수 혹은 Global 변수
- ***Heap*** : 동적 메모리 영역
- ***Stack*** : 지역변수, 매개변수, 반환 값등 일시적인 데이터

#### PCB 메모리 구조

- ***Pointer*** : Process의 준비상태, 대기상태의 큐를 구현하기 위한 구역
- ***Process State*** : 현재 Process 상태를 저장
- ***PID*** : Process의 고유 번호
- ***Program Count*** :: 다음 명령어를 가리킨다

<br>

#### 프로세스 제어 블록 (PCB, Process Control Block)
PCB는 프로세스의 정보를 저장하는 운영체제의 자료구조이다. **각 프로세스마다 독립적인 PCB를 가지고 있다.**  
프로세스는 한 번 CPU를 할당 받은 후, 한 번에 작업을 처리하지 못하고 다시 ready queue로 돌아가야할 상황이 발생한다. 
이때, 어디까지 실행했는 지 저장하기 위해서 PCB가 필요하다. 
<br>
#### PCB의 구성 요소
- **프로세스 식별자(PID)**
- **프로세스 상태**
- **프로그램 카운터**: 다음에 실행할 명령어의 주소
- **메모리 관련정보**: 페이지 테이블, 세그먼트 테이블 등
- CPU 레지스터
- CPU 스케줄링 정보: 프로세스의 우선순위, 스케줄큐에 대한 포인터
<br><br>
---

**CPU는 1개의 Process만 수행할 수 있다.** 
> 즉, 유튜브로 노래를 듣다가 인텔리제이로 코딩을 하려고 하면 노래가 꺼진다. 
> 
> 다수의 Process를 동시에 실행하기 위해, 여러개의 프로세스를 시분할로 즉, 짧은 시간 텀으로 프로세스를 CPU에 전환하며 적재해서 실행한다. 사용자 입장에서 봤을 때, 이것이 동시에 실행되는 것처럼 느낀다.



### 다중 코어 프로그래밍 (다중 처리기 시스템)
가장 먼저 알아야 하는 전제는 **하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있다.**  따라서 **단일 코어 시스템**(CPU가 하나)에서 4개의 스레드로 실행되는 응용 프로그램을 실행한다면, 이는 단순히 스레드의 실행이 시간에 따라 교대로 실행됨을 의미한다. 즉, 병렬성이 아닌 **동시성** 환경을 제공한다. 반면에, **여러 코어**를 가진 시스템에서는 시스템이 개별 스레드를 **각 코어**에 배정할 수 있으므로, **병렬성**을 환경을 제공할 수 있다.

**🌟 그렇다면 하나의 코어에 여러개의 쓰레드가 장착된 프로세서는 ???**  
여전히 하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있다. 단, 하나의 코어가 N개의 스레드를 지원한다면, 여러 스레드가 코어에 적재됨으로써 **빠른 문맥 교환이 가능하다.** 즉, 코어당 스레드 한 개인 프로세서 보다는 빠르지만, **N배의 속도를 낼 수 있는 것은 아니다.**. 단, 인텔의 하이퍼 스레딩 기술이 적용된 프로세서는 하나의 코어에서 N개의 스레드를 동시에 실행 할 수 있다.
<br><br><br>
***

#### Process A, B 실행 흐름 ####

1. A가 CPU에 적재된다.
2. B는 준비상태가 된다.
3. B를 실행하기 위해선, A가 준비상태로 내려간 후 B가 CPU에 적재된다.
4. 다시 A가 실행되기 위해선, B가 준비상태로 내려가고 A가 CPU에 적재된다.

이 과정을 ***Context Switching*** 이라고 한다.

 - _이 복잡한 과정을 해결하기 위해 등장한 것, 경량화된 프로세스인 ***Thread***_
  > 이 Thread가 경량화된 Process인 이유는,
  > > Code, Data, Heap 메모리 영역을 서로 공유하기 때문이다.
  > > 
  > > 즉, 각 Thread는 Stack 영역만 따로 가지고 있다. 자원을 공유하기 때문에 'Context Switching'이 일어날 때, 캐식 적중률이 올라간다. 
  > > 
  > > 쉽게 말해, 모조리 다 빼고 다시 넣을 필요가 없다는 것!!

#### 예시

회의실을 사용할 때, 모니터, 스피커, 리모컨을 사용한다. 다음 예약 팀이 들어올 때, 이전 프로세스 실행의 경우는 어차피 사용할 모니터, 스피커, 리모컨을 모조리 챙겨서 나간 경우이다. 다음 팀은 그것을 다시 다 챙겨서 들어와야지만 사용할 수 있다.

**그러나, Thread의 Context Switching은 공용으로 사용하는 자원은 그대로 두고 개인 노트북만 가져와서 연결하는 경우이다.**

### 프로세스의 상태
<img src="https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png" width="900" height="300">  

상태 | 설명
---- | ----
**new** | 프로세스가 새롭게 생성된 상태. 생성 후 Job Queue로 들어가 **메모리 할당을 기다림**
**ready** | 메모리를 할당 받은 후, ready queue에서 **CPU할당을 기다리는 상태**  
**running** | **cpu를 할당 받아** 실행되고 있는 상태
**waiting** | I/O작업으로 인해 blocked 된 상태
**terminated** | 프로세스가 종료된 상태  

---

### 멀티 Process vs 멀티 Thread ###
- 처리 방식의 일종이다. 즉 **1개**의 어플리케이션에 대한 처리 방식이라고 생각하자!

#### 예시

A 애플리케이션이 여러개의 일을 처리한다고 가정하자. 여러 사용자가 로그인을 요청하는 상황을 가정하자.

하나의 Process는 매번 하나의 로그인만 처리가 가능하다.
> 때문에 부모 Process를 fork() 하여 여러 자식 Process를 만들어 일을 처리한다.
> > 이 때, 자식 Process는 부모 Process와 별개의 메모리 영역을 확보한다.

반면, Thread는 1개의 Process 내에서 구분이 지어진 **실행단위**이다.
> 인텔리제이를 사용하면서 코드 수정과 동시에, 테스트코드도 돌리는 것과 같이 한 앱에서 작업의 단위가 나누어지는 경우가 있다. 
> > 이 때, 각각의 Thread가 그 작업들을 담당한다.

----

***Process***는 독립적인 메모리를 가지기 때문에 **IPC**를 통해서 통신한다. 
> 예를 들어, 같은 작업을 2명이 2개의 회의실에서 진행하다가 논의할 일이 생기면 밖으로 나와서 이야기하고 다시 들어가는 상황
> > 더 많은 메모리를 차지하고, Context Switching 비용도 비싸다.
> > 
> > 하지만 독립적인 메모리를 갖기 때문에 동기화 작업을 신경쓰지 않아도 된다.

***Thread***는 자원을 공유하기 때문에 **동기화 작업을 따로 처리해줘야한다.**
 - 스레드는 프로세스의 실행 단위이다. 스레드는 **각각의 독립적인 스레드 식별자, 프로그램 카운터, 스택을 갖고있다.**  
 - 모든 스레드는 **프로세스 내 코드, 데이터, 힙 영역의 자원을 공유한다.**
> 2명이 1개의 회의실에서 같이 일을 처리하기 때문에 논의할 일이 생기면 바로 이야기할 수 있다. (IPC가 필요하지 않음)
> > 공유된 자원으로 메모리로 인해 메모리를 효율적으로 사용할 수 있고 통신 비용, Context Switching 비용도 절감된다.

#### 그렇다면 멀티 스레드가 훨씬 좋은데 왜 멀티 프로세스를 쓸까?

- **IE**는 탭 화면을 **멀티 스레드**를 사용한다. 때문에 1개의 탭에 문제가 생기면, IE 자체가 다운된다.
 > 자원을 공유하기 때문에!

- 반면, **구글 크롬**은 **멀티 프로세스**를 사용하기 때문에 1개의 탭이 다운되더라도 크롬 자체가 다운되지 않는다.

---

###  멀티 코어
 > **하드웨어 측면으로 바라보자**
 
 > **관련 키워드는 '동시성'과 '병렬 처리'**
 
 - **싱글 코어** : 시분할로 CPU가 프로세스를 점유 ( 동시성 )
 - **멀티 코어** : 2개의 코어에서 실행 단위가 각각 진행 ( 병렬 처리 )
---

## 스케줄러
프로세스 스케줄링을 위한 Queue는 세가지가 있다  
- **Job Queue**: 현재 시스템 내에 실행중인 모든 프로세스의 집합  
- **Ready Queue**: **Job Scheduler**에 의해 **메모리**를 할당받은 후, **CPU** 할당을 기다리는 프로세스의 집합    
- **Device Queue**: I/O작업을 기다리는 프로세스의 집합  
이러한 Queue에 각 프로세스를 배정하는 역할을 스케줄러가 담당한다. 운영체제에는 세가지 프로세스 스케줄러가 존재한다  

### 장기 스케줄러
**Job Queue**에 있는 프로세스들 중 어떤 프로세스를 **Ready Queue**로 보낼지를 결정한다  
- 디스크에 적재되어 있는 프로세스 중 어떤 프로세스에게 **메모리**를 할당할 지를 결정  
- Degree of multiprogramming 제어 (실행중인 프로세스의 수 제어)  
- 프로세스 상태
  **new -> ready**  
- **현대의 시분할 시스템에서는 장기스케줄러가 없는 경우가 대부분**  

#### ✨ 장기 스케줄러가 없다면 무한히 생성되는 프로세스를 어떻게 제어하는가 ??
현대 시분할 시스템에서는 장기 스케줄러 대신 **중기 스케줄러**가 메모리 관리를 담당하고 있다.  
<br>  

### 단기 스케줄러
- **Ready Queue**에 있는 프로세스들 중 어떤 프로세스에게 **cpu**를 할당하여 실행할 지를 결정  
- 프로세스 상태  
  **ready -> running -> waiting -> ready**
- 스레드를 제공하는 운영체제에서는 실질적으로 프로세스가 아닌 **스레드**수준의 스케줄링  
<br>  

### 중기 스케줄러
- 메모리 부족시 프로세스를 메모리에서 디스크로 쫓아냄(Swap out)  
- cpu가 아닌 **memory**제어  
- Degree of multiprogramming 제어 (실행중인 프로세스의 수 제어)  
- 프로세스 상태  
  **ready -> suspended**  

#### ✨ suspended vs waiting(blocked)  
- **waiting(blocked)**: I/O 작업을 기다리는 상태. I/O 작업이 완료되면 다시 **ready queue로 돌아갈 수 있다.**  
- **suspended**: **외부적인 이유**로 실행이 정지된 상태. 메모리에서 디스크로 쫓겨난 상태. **외부(사용자)에서 재개시키지 않는 한 스스로 활성화할 수 없다.**  
<br>

  
## CPU 스케줄링
다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 **항상 실행 중인 프로세스를 가지게 하는 것이다.** 즉, 어떤 프로세스가 I/O 작업과 같이 대기해야하는 상황에 놓인 경우, 운영체제는 cpu를 해당 프로세스로부터 **회수하고 다른 프로세스에게 할당해야 한다.** 이러한 작업을 **CPU 스케줄링**이라 한다. 스레드를 지원하는 운영체제에서는 실질적으로 프로세스가 아니라 **스레드** 수준의 스케줄링을 진행한다.  
<br>

## 시스템의 종류
- 일괄처리 시스템
  - **일정량 혹은 일정 기간 동안 쌓인 데이터를 한 번에 일괄적으로 처리하는 시스템**
  - I/O작업 발생 시 cpu는 대기해야 하므로 유휴시간이 길어짐
  - **Turn around time이 길다**
  - Turn around time : 작업 요청부터 작업완료까지 걸린 시간
  
- 다중 프로그래밍 시스템
  - 메모리의 사용자영역에 프로그램이 여러개 탑재되어 있고, CPU가 이를 번갈아가며 수행한다 (동시성을 보장한다)
  - I/O작업으로 인한 **CPU 유휴 시간을 줄이기 위해 고안**
  - **단, I/O작업이 일어나야만 Context Switch가 발생함**
  - 한 프로그램이 무한루프에 빠지면 Context Switch도 발생하지 않아 시스템에 치명적
 
- **시분할 시스템**
  - **CPU의 전체 사용시간을 작은 작업 시간량으로 쪼개어 그 시간량 동안만 번갈아가면서 CPU를 할당하여 각 작업을 처리**
  - **Round Robin 방식이라고도 함**
  - **타이머 인터럽트를 통해 Context Switch 발생** 
  - **장기 스케줄러를 대신해 중기 스케줄러가 메모리 관리**

- 다중 처리 시스템
  - **여러개의 CPU**와 하나의 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
  - 하나의 CPU가 고장나더라도 다른 CPU를 이용하여 업무를 처리할 수 있으므로 신뢰성 및 안전성 증가
  
- 실시간 처리 시스템
  - 공장 생산 라인, 항공기/미사일 제어 등 엄격한 데드라인이 요구되는 곳에서 사용하는 시스템
  - 하드웨어와 완전히 밀착된 SW를 개발하여 처리 속도를 최우선시 함

<br>

## Sync - Async / Blocking - Non Blocking
- Blocking/NonBlocking은 호출되는 함수가 바로 제어권을 리턴하느냐 마느냐가 관심사
  - 바로 리턴하지 않으면 Blocking
  - 바로 리턴하면 NonBlocking

- • Synchronous/Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사
  - 호출되는 함수의 작업 완료를 호출한 함수가 신경쓰면 Synchronous
  - • 호출되는 함수의 작업 완료를 호출된 함수가 신경쓰면 Asynchronous

